<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Buana Coding</title><link>https://www.buanacoding.com/tags/go/</link><description>Recent content in Go on Buana Coding</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 02 Sep 2025 07:00:00 +0700</lastBuildDate><atom:link href="https://www.buanacoding.com/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Advanced Go Modules: Private Repos, Semantic Import v2+, and go.work</title><link>https://www.buanacoding.com/2025/09/advanced-go-modules-private-repos-semantic-import-v2-go-work.html</link><pubDate>Tue, 02 Sep 2025 07:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/advanced-go-modules-private-repos-semantic-import-v2-go-work.html</guid><description>&lt;p>Go modules revolutionized dependency management in the Go ecosystem when they were introduced in Go 1.11. While most developers are familiar with basic module operations like &lt;code>go mod init&lt;/code> and &lt;code>go get&lt;/code>, there are several advanced features that can significantly improve your development workflow. In this comprehensive guide, we&amp;rsquo;ll explore three critical advanced concepts: working with private repositories, handling semantic import versioning v2 and beyond, and leveraging go.work for multi-module projects.&lt;/p></description></item><item><title>The Complete Guide to slog (Go 1.21+): Modern Structured Logging in Go (2025)</title><link>https://www.buanacoding.com/2025/09/complete-guide-slog-go-structured-logging-2025.html</link><pubDate>Mon, 01 Sep 2025 08:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/complete-guide-slog-go-structured-logging-2025.html</guid><description>&lt;p>Go 1.21 introduced &lt;code>log/slog&lt;/code>, a standard structured logging API that finally brings first‑class JSON and attribute‑based logging to the standard library. If you’ve used &lt;code>zap&lt;/code> or &lt;code>logrus&lt;/code>, the core ideas will feel familiar—just simpler and standardized.&lt;/p>
&lt;p>This guide takes you from zero to production-ready logging with &lt;code>slog&lt;/code>. We&amp;rsquo;ll start with basic setup, then gradually build up to advanced patterns like HTTP middleware, security, testing, and observability integration. Each section includes working examples you can run immediately.&lt;/p></description></item><item><title>gRPC in Go: Complete Guide from Basics to Production Ready Services</title><link>https://www.buanacoding.com/2025/08/grpc-in-go-complete-guide-basics-production.html</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0000</pubDate><guid>https://www.buanacoding.com/2025/08/grpc-in-go-complete-guide-basics-production.html</guid><description>&lt;p>Building modern distributed systems is tricky business - you need services that can talk to each other quickly and reliably. That&amp;rsquo;s where gRPC comes in and absolutely crushes it. I&amp;rsquo;ve been building REST APIs for years, but when I first tried gRPC, it was like switching from a bicycle to a sports car. The speed difference is insane, plus you get type safety and can use it with practically any programming language.&lt;/p></description></item><item><title>Connecting to PostgreSQL in Go using sqlx</title><link>https://www.buanacoding.com/2025/05/connecting-postgresql-in-go-using-sqlx.html</link><pubDate>Sun, 25 May 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/05/connecting-postgresql-in-go-using-sqlx.html</guid><description>&lt;p>In modern web applications, storing and retrieving data from a database is a fundamental requirement. Go provides a low-level database/sql package, but using it directly can be verbose and repetitive. Thankfully, sqlx extends database/sql by adding useful features like struct scanning and named queries, making database operations in Go much easier.&lt;/p>
&lt;p>In this article, we’ll walk through how to connect a Go application to a PostgreSQL database using sqlx, and how to perform basic CRUD operations.&lt;/p></description></item><item><title>Structuring Go Projects: Clean Project Structure and Best Practices</title><link>https://www.buanacoding.com/2025/05/structuring-go-projects-clean-architecture.html</link><pubDate>Sun, 18 May 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/05/structuring-go-projects-clean-architecture.html</guid><description>&lt;p>When you start building larger applications in Go, having a clean and maintainable project structure is essential. Unlike some other languages or frameworks that enforce certain patterns, Go gives you a lot of freedom in how you organize your code. While this is powerful, it can also lead to messy projects if not handled carefully.&lt;/p>
&lt;p>In this guide, we&amp;rsquo;ll explore how to structure Go projects following clean architecture principles and best practices that many professional Go developers use.&lt;/p></description></item><item><title>How to Build a REST API in Go using net/http</title><link>https://www.buanacoding.com/2025/05/how-to-build-rest-api-in-go-using-net-http.html</link><pubDate>Sun, 11 May 2025 08:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/05/how-to-build-rest-api-in-go-using-net-http.html</guid><description>&lt;p>Building a REST API in Go is one of the most practical ways to learn how Go handles HTTP servers, &lt;a href="https://www.buanacoding.com/2025/04/working-with-json-in-go-encode-decode.html">
 JSON
&lt;/a>
, and struct-based logic. In this tutorial, you’ll learn how to create a simple RESTful API using the standard net/http package—without using any third-party frameworks. This is a great starting point before moving to more complex architectures.&lt;/p>
&lt;p>In this guide, we’ll create a simple API for managing books. Each book will have an ID, title, and author.&lt;/p></description></item><item><title>Working with JSON in Go: Encode, Decode, and Tag Structs</title><link>https://www.buanacoding.com/2025/04/working-with-json-in-go-encode-decode.html</link><pubDate>Wed, 30 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/working-with-json-in-go-encode-decode.html</guid><description>&lt;p>JSON (JavaScript Object Notation) is a widely used data format in APIs and web applications. Go provides strong support for JSON through the standard &lt;code>encoding/json&lt;/code> package. In this article, you’ll learn how to parse JSON into structs, generate JSON from Go data, use struct tags, and work with nested or dynamic structures.&lt;/p>
&lt;p>In this article, you’ll learn:&lt;/p>
&lt;ul>
&lt;li>How to encode Go structs to JSON&lt;/li>
&lt;li>How to decode JSON into Go structs&lt;/li>
&lt;li>Using JSON tags to customize field names&lt;/li>
&lt;li>Working with maps and dynamic JSON&lt;/li>
&lt;li>Handling nested JSON structures&lt;/li>
&lt;li>Best practices and error handling&lt;/li>
&lt;/ul>
&lt;h2 id="encoding-structs-to-json">Encoding Structs to JSON&lt;/h2>
&lt;p>Use &lt;code>json.Marshal&lt;/code> to convert Go structs into JSON strings:&lt;/p></description></item><item><title>File Handling in Go: Read, Write, and Manage Files</title><link>https://www.buanacoding.com/2025/04/file-handling-in-go-read-write-and.html</link><pubDate>Tue, 29 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/file-handling-in-go-read-write-and.html</guid><description>&lt;p>In Go, file handling is straightforward and powerful. You can create, read, write, and manage files using standard packages like &lt;code>os&lt;/code>, &lt;code>io&lt;/code>, and &lt;code>ioutil&lt;/code> (deprecated but still common). Understanding how to work with files is essential when building CLI tools, web servers, or any application that deals with local data.&lt;/p>
&lt;p>In this article, you’ll learn:&lt;/p>
&lt;ul>
&lt;li>How to create and write to a file&lt;/li>
&lt;li>How to read a file&lt;/li>
&lt;li>Appending data to files&lt;/li>
&lt;li>Working with directories&lt;/li>
&lt;li>Checking if a file exists&lt;/li>
&lt;li>Best practices and error handling&lt;/li>
&lt;/ul>
&lt;h2 id="creating-and-writing-to-a-file">Creating and Writing to a File&lt;/h2>
&lt;p>To create and write content to a file:&lt;/p></description></item><item><title>Synchronizing Goroutines in Go: Using sync.Mutex and sync.Once</title><link>https://www.buanacoding.com/2025/04/synchronizing-goroutines-in-go-using.html</link><pubDate>Mon, 28 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/synchronizing-goroutines-in-go-using.html</guid><description>&lt;p>When you write concurrent programs in Go, multiple goroutines may try to access and modify the same data at the same time. Without proper synchronization, this leads to race conditions, bugs, or crashes. Go provides tools like &lt;code>sync.Mutex&lt;/code>, &lt;code>sync.RWMutex&lt;/code>, and &lt;code>sync.Once&lt;/code> to safely share data across goroutines.&lt;/p>
&lt;p>In this article, you’ll learn:&lt;/p>
&lt;ul>
&lt;li>What race conditions are and how to avoid them&lt;/li>
&lt;li>How to use &lt;code>sync.Mutex&lt;/code> to protect data&lt;/li>
&lt;li>Using &lt;code>sync.RWMutex&lt;/code> for read-write access&lt;/li>
&lt;li>How &lt;code>sync.Once&lt;/code> ensures code runs only once&lt;/li>
&lt;li>Real-world examples and best practices&lt;/li>
&lt;/ul>
&lt;h2 id="what-is-a-race-condition">What Is a Race Condition?&lt;/h2>
&lt;p>A race condition happens when two or more goroutines access the same variable at the same time, and at least one of them is modifying it. This can cause unexpected behavior or corrupted data.&lt;/p></description></item><item><title>Using Context in Go: Cancellation, Timeout, and Deadlines Explained</title><link>https://www.buanacoding.com/2025/04/using-context-in-go-cancellation.html</link><pubDate>Sun, 27 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/using-context-in-go-cancellation.html</guid><description>&lt;p>As your Go applications become more concurrent and complex, you&amp;rsquo;ll need a way to manage the lifecycle of your goroutines—especially when you want to cancel them, set timeouts, or propagate deadlines. This is where the &lt;code>context&lt;/code> package comes in. It&amp;rsquo;s the idiomatic way in Go to control concurrent processes gracefully and reliably.&lt;/p>
&lt;p>In this article, you’ll learn:&lt;/p>
&lt;ul>
&lt;li>What &lt;code>context&lt;/code> is and why it’s important&lt;/li>
&lt;li>Using &lt;code>context.Background()&lt;/code> and &lt;code>context.TODO()&lt;/code>&lt;/li>
&lt;li>How to cancel a goroutine with &lt;code>context.WithCancel()&lt;/code>&lt;/li>
&lt;li>How to set a timeout or deadline&lt;/li>
&lt;li>How to check if a context is done&lt;/li>
&lt;li>Real-world examples and best practices&lt;/li>
&lt;/ul>
&lt;h2 id="what-is-context">What Is Context?&lt;/h2>
&lt;p>The &lt;code>context&lt;/code> package provides a way to carry deadlines, cancellation signals, and other request-scoped values across function boundaries and between goroutines.&lt;/p></description></item><item><title>Concurrency in Go: Goroutines and Channels Explained</title><link>https://www.buanacoding.com/2025/04/concurrency-in-go-goroutines-and.html</link><pubDate>Sat, 26 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/concurrency-in-go-goroutines-and.html</guid><description>&lt;p>One of the most powerful features of Go is its built-in support for concurrency. Go makes it easy to write programs that perform multiple tasks at the same time, thanks to goroutines and channels. Unlike traditional multithreading, Go provides a lightweight and clean way to build concurrent systems with minimal overhead and boilerplate.&lt;/p>
&lt;p>In this article, you’ll learn:&lt;/p>
&lt;ul>
&lt;li>The difference between concurrency and parallelism&lt;/li>
&lt;li>What goroutines are and how to use them&lt;/li>
&lt;li>How channels allow communication between goroutines&lt;/li>
&lt;li>Buffered vs unbuffered channels&lt;/li>
&lt;li>The &lt;code>select&lt;/code> statement&lt;/li>
&lt;li>Common concurrency problems and how to avoid them&lt;/li>
&lt;li>Real-world examples and best practices&lt;/li>
&lt;/ul>
&lt;h2 id="concurrency-vs-parallelism">Concurrency vs Parallelism&lt;/h2>
&lt;p>Concurrency means doing multiple things at once (interleaved), while parallelism means running them simultaneously on different processors. Go’s concurrency model allows you to write code that is concurrent, and Go’s runtime handles whether it is executed in parallel depending on available CPU cores.&lt;/p></description></item><item><title>Generics in Go: Writing Reusable and Type-Safe Code</title><link>https://www.buanacoding.com/2025/04/generics-in-go-writing-reusable-and-type-safe-code.html</link><pubDate>Fri, 25 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/generics-in-go-writing-reusable-and-type-safe-code.html</guid><description>&lt;p>Generics were introduced in Go 1.18, marking a significant evolution of the language. They allow you to write flexible, reusable code without sacrificing type safety. With generics, you can define functions, types, and data structures that work with different types, all while maintaining strong compile-time checks.&lt;/p>
&lt;p>In this article, you’ll learn:&lt;/p>
&lt;ul>
&lt;li>What generics are and why they matter&lt;/li>
&lt;li>How to define generic functions and types&lt;/li>
&lt;li>Type parameters and constraints&lt;/li>
&lt;li>Real-world examples of generics&lt;/li>
&lt;li>Best practices when using generics in Go&lt;/li>
&lt;/ul>
&lt;h2 id="what-are-generics">What Are Generics?&lt;/h2>
&lt;p>Generics let you write code that works with different data types while keeping the benefits of static typing. Before generics, developers often used &lt;code>interface{}&lt;/code> and type assertions to achieve flexibility, but that meant losing compile-time type safety.&lt;/p></description></item><item><title>Benchmarking in Go: Measuring Performance with testing.B</title><link>https://www.buanacoding.com/2025/04/benchmarking-in-go-measuring.html</link><pubDate>Thu, 24 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/benchmarking-in-go-measuring.html</guid><description>&lt;p>Benchmarking is the process of measuring the performance of code. In Go, benchmarking is built into the standard &lt;code>testing&lt;/code> package, making it easy to test how fast your functions run. Whether you&amp;rsquo;re comparing two algorithms, optimizing critical sections of code, or experimenting with concurrency, benchmarking helps you make informed decisions.&lt;/p>
&lt;p>This article will walk you through:&lt;/p>
&lt;ul>
&lt;li>What is benchmarking and why it matters&lt;/li>
&lt;li>How to write benchmark functions in Go&lt;/li>
&lt;li>Interpreting benchmark results&lt;/li>
&lt;li>Using &lt;code>b.ResetTimer()&lt;/code>, &lt;code>b.StopTimer()&lt;/code>, and &lt;code>b.StartTimer()&lt;/code>&lt;/li>
&lt;li>Common use cases for benchmarking&lt;/li>
&lt;li>Best practices for writing meaningful benchmarks&lt;/li>
&lt;/ul>
&lt;h2 id="why-benchmarking-is-important">Why Benchmarking is Important&lt;/h2>
&lt;p>Benchmarking allows you to evaluate performance based on data, not assumptions. You can compare the execution time of different code versions, measure improvements, and catch performance regressions early. This is crucial for optimizing critical parts of applications such as sorting, searching, or processing large datasets.&lt;/p></description></item><item><title>Testing in Go: Writing Unit Tests with the Testing Package</title><link>https://www.buanacoding.com/2025/04/testing-in-go-writing-unit-tests-with.html</link><pubDate>Wed, 23 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/testing-in-go-writing-unit-tests-with.html</guid><description>&lt;p>Testing is one of the most important parts of software development, yet often overlooked. In Go, testing is not an afterthought — it&amp;rsquo;s built into the language itself through the powerful and easy-to-use &lt;code>testing&lt;/code> package. Whether you&amp;rsquo;re building a web app, API, or CLI tool, writing tests will help you catch bugs early, document your code, and refactor safely.&lt;/p>
&lt;p>This article will help you understand:&lt;/p>
&lt;ul>
&lt;li>Why testing matters in software development&lt;/li>
&lt;li>The basics of writing tests in Go&lt;/li>
&lt;li>Using &lt;code>t.Error&lt;/code>, &lt;code>t.Fail&lt;/code>, and &lt;code>t.Fatal&lt;/code>&lt;/li>
&lt;li>Table-driven tests&lt;/li>
&lt;li>Running and understanding test results&lt;/li>
&lt;li>Measuring code coverage&lt;/li>
&lt;li>Best practices for writing useful tests&lt;/li>
&lt;/ul>
&lt;h2 id="why-testing-is-important">Why Testing is Important&lt;/h2>
&lt;p>Testing helps you ensure that your code works as expected — not just today, but as it evolves. Without tests, it&amp;rsquo;s risky to make changes because you can&amp;rsquo;t be confident you haven&amp;rsquo;t broken something.&lt;/p></description></item><item><title>Error Handling in Go: Managing Errors the Right Way</title><link>https://www.buanacoding.com/2025/04/error-handling-in-go-managing-errors.html</link><pubDate>Tue, 22 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/error-handling-in-go-managing-errors.html</guid><description>&lt;p>Error handling is a core part of Go programming. Unlike many languages that use exceptions, Go takes a more straightforward and explicit approach. In Go, functions often return an error as the last return value, and it&amp;rsquo;s the developer’s job to check and handle it. This method may seem verbose at first, but it leads to more robust and predictable code.&lt;/p>
&lt;p>In this article, you&amp;rsquo;ll learn:&lt;/p>
&lt;ul>
&lt;li>What an error is in Go&lt;/li>
&lt;li>How to handle errors using &lt;code>if err != nil&lt;/code>&lt;/li>
&lt;li>Creating custom errors&lt;/li>
&lt;li>Error wrapping with Go 1.13+&lt;/li>
&lt;li>Custom error types&lt;/li>
&lt;li>Using &lt;code>panic&lt;/code> and &lt;code>recover&lt;/code> (when and why)&lt;/li>
&lt;li>Best practices for error handling&lt;/li>
&lt;/ul>
&lt;h2 id="what-is-an-error-in-go">What is an Error in Go?&lt;/h2>
&lt;p>In Go, the &lt;code>error&lt;/code> type is a built-in interface:&lt;/p></description></item><item><title>Interfaces in Go: Building Flexible and Reusable Code</title><link>https://www.buanacoding.com/2025/04/interfaces-in-go-building-flexible-and.html</link><pubDate>Mon, 21 Apr 2025 10:30:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/interfaces-in-go-building-flexible-and.html</guid><description>&lt;p>Interfaces are one of the most important features in Go. They allow you to write flexible, reusable, and loosely coupled code. In Go, an interface defines a set of method signatures, and any type that implements those methods satisfies the interface — without needing to explicitly declare that it does so. This is a powerful concept that supports polymorphism and clean architecture in Go applications.&lt;/p>
&lt;p>In this article, you&amp;rsquo;ll learn:&lt;/p></description></item><item><title>Understanding Pointers in Go: Reference Types and Receivers Explained</title><link>https://www.buanacoding.com/2025/04/understanding-pointers-in-go-reference.html</link><pubDate>Sun, 20 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/understanding-pointers-in-go-reference.html</guid><description>&lt;p>In Go, understanding pointers is essential if you want to work effectively with functions, methods, and memory-efficient code. Unlike some other languages, Go’s approach to pointers is clean and straightforward—there’s no pointer arithmetic, and most things can be done without overly complex syntax.&lt;/p>
&lt;p>This article will help you understand:&lt;/p>
&lt;ul>
&lt;li>What pointers are in Go and how they work&lt;/li>
&lt;li>Using pointers in functions&lt;/li>
&lt;li>Method receivers: value vs pointer&lt;/li>
&lt;li>Choosing between value or pointer receiver&lt;/li>
&lt;li>Common mistakes with pointers&lt;/li>
&lt;li>Best practices for using pointers effectively&lt;/li>
&lt;/ul>
&lt;h2 id="what-is-a-pointer">What is a Pointer?&lt;/h2>
&lt;p>A pointer is a variable that stores the memory address of another variable. You use the &lt;code>&amp;amp;&lt;/code> operator to get the address and &lt;code>*&lt;/code> to access the value at that address.&lt;/p></description></item><item><title>Structs and Methods in Go: Defining and Using Custom Types</title><link>https://www.buanacoding.com/2025/04/structs-and-methods-in-go-defining-and.html</link><pubDate>Sat, 19 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/structs-and-methods-in-go-defining-and.html</guid><description>&lt;p>In Go, a struct is a powerful way to group related data together. It allows you to define your own custom types by combining variables (also called fields). Structs are often used to model real-world entities like users, products, or messages. When combined with methods, structs become the foundation for writing clean and reusable code in Go.&lt;/p>
&lt;p>In this article, you&amp;rsquo;ll learn:&lt;/p>
&lt;ul>
&lt;li>How to define and use structs in Go&lt;/li>
&lt;li>How to attach methods to a struct&lt;/li>
&lt;li>The difference between value and pointer receivers&lt;/li>
&lt;li>Best practices for using structs and methods effectively&lt;/li>
&lt;/ul>
&lt;h2 id="defining-a-struct">Defining a Struct&lt;/h2>
&lt;p>To define a struct, you use the &lt;code>type&lt;/code> keyword followed by the name of the struct and the &lt;code>struct&lt;/code> keyword:&lt;/p></description></item><item><title>Understanding Functions in Go: A Beginner's Guide</title><link>https://www.buanacoding.com/2025/04/understanding-functions-in-go-beginners.html</link><pubDate>Fri, 18 Apr 2025 11:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/understanding-functions-in-go-beginners.html</guid><description>&lt;p>Functions are an essential part of programming in any language, and Go is no exception. A function lets you organize code into reusable blocks, which helps reduce duplication and improve readability. In this article, you’ll learn how functions work in Go, how to define them, use them, and apply best practices.&lt;/p>
&lt;p>This guide covers:&lt;/p>
&lt;ul>
&lt;li>How to define and call a function in Go&lt;/li>
&lt;li>Function parameters and return values&lt;/li>
&lt;li>Multiple return values&lt;/li>
&lt;li>Named return values&lt;/li>
&lt;li>Variadic functions&lt;/li>
&lt;li>Functions as values and arguments&lt;/li>
&lt;li>Best practices for clean function design&lt;/li>
&lt;/ul>
&lt;h2 id="defining-and-calling-a-function">Defining and Calling a Function&lt;/h2>
&lt;p>To define a function in Go, use the &lt;code>func&lt;/code> keyword, followed by the function name, parameters, and return type (if any). Here&amp;rsquo;s a simple example:&lt;/p></description></item><item><title>Working with Collections in Go: Arrays, Slices, and Maps Explained</title><link>https://www.buanacoding.com/2025/04/working-with-collections-in-go-arrays.html</link><pubDate>Thu, 17 Apr 2025 22:46:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/working-with-collections-in-go-arrays.html</guid><description>&lt;p>When building applications in Go, it&amp;rsquo;s common to work with groups of data. For example, you might want to store a list of user names, or map names to scores. In Go, you can use collections like arrays, slices, and maps to do that.&lt;/p>
&lt;p>In this article, we’ll explore:&lt;/p>
&lt;ul>
&lt;li>What arrays are and how they work&lt;/li>
&lt;li>How slices offer more flexibility&lt;/li>
&lt;li>What maps are and how to use them&lt;/li>
&lt;li>Common operations with collections&lt;/li>
&lt;li>Practical examples to understand the difference between them&lt;/li>
&lt;/ul>
&lt;p>Let’s dive in and learn how Go helps us manage grouped data efficiently.&lt;/p></description></item><item><title>Understanding Loops in Go: for, range, break, and continue Explained</title><link>https://www.buanacoding.com/2025/04/understanding-loops-in-go-for-range.html</link><pubDate>Wed, 16 Apr 2025 22:06:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/understanding-loops-in-go-for-range.html</guid><description>&lt;p>Loops are a key part of programming. They let us run the same piece of code multiple times without repeating ourselves. In Go, loops are simple but powerful — and they&amp;rsquo;re built using just one keyword: for.&lt;/p>
&lt;p>In this article, we’ll explore:&lt;/p>
&lt;ul>
&lt;li>The basic for loop in Go&lt;/li>
&lt;li>Using for as a while loop&lt;/li>
&lt;li>Looping with range&lt;/li>
&lt;li>Breaking or skipping parts of loops with break and continue&lt;/li>
&lt;li>Real-world examples to help you understand how loops work&lt;/li>
&lt;/ul>
&lt;h2 id="what-is-a-loop">What is a Loop?&lt;/h2>
&lt;p>A loop is a way to repeat a block of code as long as a condition remains true. Instead of writing similar code many times, we can put it in a loop and let the program handle the repetition. This makes our code shorter, cleaner, and easier to manage. Go uses the keyword for for all loop types, which makes it both simple and flexible.&lt;/p></description></item><item><title>Understanding Conditional Statements in Go (if, switch, etc.)</title><link>https://www.buanacoding.com/2025/04/understanding-conditional-statements-in.html</link><pubDate>Tue, 15 Apr 2025 19:09:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/understanding-conditional-statements-in.html</guid><description>&lt;p>Conditional statements are one of the essential building blocks in any programming language, including Go. They allow us to make decisions in our code — telling the program to do something only if a certain condition is true.&lt;/p>
&lt;p>In this article, we will explore:&lt;/p>
&lt;ul>
&lt;li>The if, else, and else if statements&lt;/li>
&lt;li>The switch statement&lt;/li>
&lt;li>Best practices for using conditionals in Go&lt;/li>
&lt;li>Real examples to help you practice&lt;/li>
&lt;/ul>
&lt;h2 id="what-is-a-conditional-statement">What is a Conditional Statement?&lt;/h2>
&lt;p>A conditional statement evaluates whether a condition is true or false. Based on that, your Go program can choose which block of code to execute.&lt;/p></description></item><item><title>Understanding String Data Type in Go: Basics and Practical Examples</title><link>https://www.buanacoding.com/2024/07/understanding-string-data-type-in-go.html</link><pubDate>Mon, 22 Jul 2024 07:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2024/07/understanding-string-data-type-in-go.html</guid><description>&lt;p>In our series on understanding data types in the Go programming language, after discussing numeric and boolean types, we will now explore strings. Strings are one of the most frequently used data types in programming due to their ubiquitous use in handling text. In Go, strings have several unique characteristics that we will explore in this article.&lt;/p>
&lt;h2 id="introduction-to-strings">Introduction to Strings&lt;/h2>
&lt;p>In Go, a string is a sequence of immutable bytes. This means that once a string value is set, it cannot be changed without creating a new string.&lt;/p></description></item><item><title>Understanding Numeric Data Type In Go : Basics and Practical Examples</title><link>https://www.buanacoding.com/2024/07/understanding-numeric-data-type-in-go.html</link><pubDate>Sat, 20 Jul 2024 19:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2024/07/understanding-numeric-data-type-in-go.html</guid><description>&lt;p>Go, also known as Golang, is a statically typed language developed by Google. It&amp;rsquo;s known for its simplicity and efficiency, especially when it comes to systems and concurrent programming. In this article, we&amp;rsquo;ll explore the numeric types in Go and provide practical examples to illustrate their usage.&lt;/p>
&lt;h2 id="basic-numeric-types">Basic Numeric Types&lt;/h2>
&lt;p>Go offers several basic numeric types categorized into integers, floating point numbers, and complex numbers. Here’s a quick overview:&lt;/p>
&lt;h3 id="integer">Integer&lt;/h3>
&lt;p>Integer types are divided into two categories, signed and unsigned. The signed integers &lt;strong>int8, int16, int32, int64&lt;/strong> can hold both negative and positive values, whereas unsigned integers &lt;strong>int8, int16, int32, int64&lt;/strong> can only hold positive values and zero.&lt;/p></description></item><item><title>Understanding Booleans Data Type in Go: Basics and Practical Examples</title><link>https://www.buanacoding.com/2024/07/understanding-booleans-in-go-basics.html</link><pubDate>Thu, 18 Jul 2024 19:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2024/07/understanding-booleans-in-go-basics.html</guid><description>&lt;p>In the Go programming language, as in many other programming languages, the boolean data type is fundamental. It represents truth values, either true or false. Booleans are crucial in software development for decision-making, allowing developers to control the flow of execution through conditional statements like if, else, and looping constructs such as for.&lt;/p>
&lt;p>Declaration and Initialization&lt;/p>
&lt;hr>
&lt;p>To declare a boolean in Go, you use the keyword &lt;strong>bool&lt;/strong>. Here&amp;rsquo;s how you can declare and initialize a boolean variable:&lt;/p></description></item><item><title>Easiest Way to Install Golang on Linux: Snap or Manual Source?</title><link>https://www.buanacoding.com/2024/04/easiest-way-install-golang-on-linux.html</link><pubDate>Mon, 08 Apr 2024 06:23:00 +0700</pubDate><guid>https://www.buanacoding.com/2024/04/easiest-way-install-golang-on-linux.html</guid><description>&lt;p>Learning Golang recently opened up new perspectives for me in software development. One of the best ways to solidify your understanding is by teaching others. That’s why in this article, I’m sharing my experience installing Go on Linux—using both Snap and manual source installation.&lt;/p>
&lt;p>Writing this guide not only helps others get started, but also helps reinforce the steps in my own memory.&lt;/p>
&lt;hr>
&lt;h2 id="installing-golang-using-snap">Installing Golang Using Snap&lt;/h2>
&lt;p>Snap is a universal package manager developed by Canonical (Ubuntu’s creator). It simplifies app installation by bundling dependencies, ensuring compatibility across most Linux distributions.&lt;/p></description></item></channel></rss>