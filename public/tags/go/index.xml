<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Buana Coding</title><link>https://www.buanacoding.com/tags/go/</link><description>Recent content in Go on Buana Coding</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 29 Sep 2025 08:00:00 +0700</lastBuildDate><atom:link href="https://www.buanacoding.com/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Service Discovery in Microservices Golang - Consul and etcd Implementation</title><link>https://www.buanacoding.com/2025/09/service-discovery-microservices-golang-consul-etcd.html</link><pubDate>Mon, 29 Sep 2025 08:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/service-discovery-microservices-golang-consul-etcd.html</guid><description>&lt;p&gt;In the early days of web development, finding services was simple. Your database lived at &lt;code&gt;localhost:5432&lt;/code&gt;, your cache at &lt;code&gt;localhost:6379&lt;/code&gt;, and everything was predictable. But when you move to microservices, suddenly you have dozens of services spinning up and down across multiple servers, and nobody knows where anything is anymore.&lt;/p&gt;
&lt;p&gt;This is where service discovery becomes your lifeline. Instead of hardcoding addresses and hoping for the best, you get a dynamic phone book that keeps track of who&amp;rsquo;s available, where they live, and whether they&amp;rsquo;re actually working. After building several distributed systems in Go, I can tell you that getting service discovery right is often the difference between a system that scales gracefully and one that becomes an operational nightmare.&lt;/p&gt;</description></item><item><title>API Gateway with Golang - Load Balancing and Rate Limiting Implementation</title><link>https://www.buanacoding.com/2025/09/api-gateway-golang-load-balancing-rate-limiting.html</link><pubDate>Mon, 29 Sep 2025 07:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/api-gateway-golang-load-balancing-rate-limiting.html</guid><description>&lt;p&gt;When you&amp;rsquo;re building distributed systems, one component stands between chaos and order: the API Gateway. Think of it as the bouncer at an exclusive club - it decides who gets in, where they go, and how fast they can enter. After working with various microservice architectures, I can tell you that a well-implemented API Gateway is often the difference between a system that scales gracefully and one that crumbles under pressure.&lt;/p&gt;</description></item><item><title>Event-Driven Architecture with Golang and Message Queues</title><link>https://www.buanacoding.com/2025/09/event-driven-architecture-golang-message-queues.html</link><pubDate>Sat, 27 Sep 2025 03:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/event-driven-architecture-golang-message-queues.html</guid><description>&lt;p&gt;Traditional request-response architectures work well for simple applications, but as systems grow in complexity and scale, they often become bottlenecks. Event-driven architecture gives you a better way to build systems by letting components talk to each other through messages instead of direct calls. When combined with Go&amp;rsquo;s excellent concurrency model and robust ecosystem, event-driven systems become powerful tools for building scalable, resilient applications.&lt;/p&gt;
&lt;p&gt;In this guide, you&amp;rsquo;ll learn how to build event-driven systems using Go and message queues that actually work in production. We&amp;rsquo;ll explore event sourcing patterns, CQRS implementation, and practical strategies for building systems that can handle high throughput while maintaining data consistency and system reliability.&lt;/p&gt;</description></item><item><title>Microservices with Golang - Architecture and Implementation Guide</title><link>https://www.buanacoding.com/2025/09/microservices-golang-architecture-implementation-guide.html</link><pubDate>Sat, 27 Sep 2025 00:01:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/microservices-golang-architecture-implementation-guide.html</guid><description>&lt;p&gt;Moving from monolithic to microservices architecture has become one of the biggest changes in how we build software today. While monolithic applications bundle all functionality into a single deployable unit, microservices break down applications into smaller, independent services that communicate over well-defined APIs. When combined with Go&amp;rsquo;s performance characteristics and deployment simplicity, microservices become a powerful approach for building scalable, maintainable systems.&lt;/p&gt;
&lt;p&gt;In this guide, you&amp;rsquo;ll learn how to design, build, and deploy microservices using Go. We&amp;rsquo;ll cover architectural patterns, service communication strategies, containerization, and production deployment techniques that will help you build robust distributed systems.&lt;/p&gt;</description></item><item><title>Building GraphQL Server with gqlgen in Golang</title><link>https://www.buanacoding.com/2025/09/building-graphql-server-gqlgen-golang.html</link><pubDate>Fri, 26 Sep 2025 03:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/building-graphql-server-gqlgen-golang.html</guid><description>&lt;p&gt;Modern web applications require APIs that can efficiently serve data to various clients with different needs. While traditional REST APIs have served this purpose for years, GraphQL has emerged as a powerful alternative that solves many common API development challenges. When building GraphQL servers in Go, gqlgen stands out as the most mature and feature-rich library available.&lt;/p&gt;
&lt;p&gt;This comprehensive guide will walk you through building a complete GraphQL server using gqlgen, from initial setup to production deployment. We&amp;rsquo;ll cover schema design, resolver implementation, database integration, and performance optimization techniques that will help you build robust, scalable GraphQL APIs.&lt;/p&gt;</description></item><item><title>GraphQL with Golang - A Modern Alternative to REST API</title><link>https://www.buanacoding.com/2025/09/graphql-golang-modern-alternative-rest-api.html</link><pubDate>Fri, 26 Sep 2025 02:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/graphql-golang-modern-alternative-rest-api.html</guid><description>&lt;p&gt;The landscape of API development has evolved significantly over the past decade. While REST APIs have been the dominant architecture for building web services, GraphQL has emerged as a compelling alternative that addresses many limitations of traditional REST-based approaches. When combined with Go&amp;rsquo;s performance and simplicity, GraphQL creates a powerful foundation for modern API development.&lt;/p&gt;
&lt;h2 id="understanding-graphql-beyond-traditional-rest"&gt;Understanding GraphQL: Beyond Traditional REST&lt;/h2&gt;
&lt;p&gt;GraphQL represents a paradigm shift in how we think about API design and data fetching. Unlike REST, which exposes multiple endpoints for different resources, GraphQL provides a single endpoint that can handle complex queries with precise data requirements.&lt;/p&gt;</description></item><item><title>Fiber vs Gin vs Echo - Go Framework Comparison 2025</title><link>https://www.buanacoding.com/2025/09/fiber-vs-gin-vs-echo-golang-framework-comparison-2025.html</link><pubDate>Thu, 25 Sep 2025 03:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/fiber-vs-gin-vs-echo-golang-framework-comparison-2025.html</guid><description>&lt;p&gt;Choosing the right web framework can make or break your Go project. I&amp;rsquo;ve spent the last three years working with different Go frameworks across various production systems, and the three names that consistently come up in every discussion are Gin, Fiber, and Echo. Each has its passionate advocates, but which one should you actually choose in 2025?&lt;/p&gt;
&lt;p&gt;The landscape has evolved significantly since these frameworks first appeared. Performance gaps have narrowed, feature sets have matured, and the ecosystem around each has grown substantially. What used to be clear-cut decisions based on pure speed are now more nuanced choices that depend on your specific use case, team experience, and architectural requirements.&lt;/p&gt;</description></item><item><title>Building REST API with Gin Framework Golang - Production Ready</title><link>https://www.buanacoding.com/2025/09/building-rest-api-gin-framework-golang-production-ready.html</link><pubDate>Thu, 25 Sep 2025 02:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/building-rest-api-gin-framework-golang-production-ready.html</guid><description>&lt;p&gt;Building a REST API might seem straightforward at first glance, but creating one that&amp;rsquo;s actually ready for production is a different beast entirely. After spending years working with various Go frameworks, I can tell you that the Gin framework hits that sweet spot between developer productivity and performance that makes it perfect for building robust APIs.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;ve been building &lt;a href="https://www.buanacoding.com/2025/05/how-to-build-rest-api-in-go-using-net-http.html"&gt;
 basic REST APIs with Go&amp;rsquo;s net/http package
&lt;/a&gt;
, you&amp;rsquo;ve probably noticed how much boilerplate code you need to write for routing, middleware, and request handling. That&amp;rsquo;s where Gin shines - it provides all the essential features you need while maintaining the performance advantages that make Go special.&lt;/p&gt;</description></item><item><title>Private Repos, Semantic Import v2+, and go.work</title><link>https://www.buanacoding.com/2025/09/advanced-go-modules-private-repos-semantic-import-v2-go-work.html</link><pubDate>Tue, 02 Sep 2025 19:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/advanced-go-modules-private-repos-semantic-import-v2-go-work.html</guid><description>&lt;p&gt;Go modules revolutionized dependency management in the Go ecosystem when they were introduced in Go 1.11. While most developers are familiar with basic module operations like &lt;code&gt;go mod init&lt;/code&gt; and &lt;code&gt;go get&lt;/code&gt;, there are several advanced features that can significantly improve your development workflow. In this comprehensive guide, we&amp;rsquo;ll explore three critical advanced concepts: working with private repositories, handling semantic import versioning v2 and beyond, and leveraging go.work for multi-module projects.&lt;/p&gt;</description></item><item><title>The Complete Guide to slog (Go 1.21+) Modern Structured Logging in Go (2025)</title><link>https://www.buanacoding.com/2025/09/complete-guide-slog-go-structured-logging-2025.html</link><pubDate>Mon, 01 Sep 2025 08:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/complete-guide-slog-go-structured-logging-2025.html</guid><description>&lt;p&gt;Go 1.21 introduced &lt;code&gt;log/slog&lt;/code&gt;, a standard structured logging API that finally brings first‑class JSON and attribute‑based logging to the standard library. If you’ve used &lt;code&gt;zap&lt;/code&gt; or &lt;code&gt;logrus&lt;/code&gt;, the core ideas will feel familiar—just simpler and standardized.&lt;/p&gt;
&lt;p&gt;This guide takes you from zero to production-ready logging with &lt;code&gt;slog&lt;/code&gt;. We&amp;rsquo;ll start with basic setup, then gradually build up to advanced patterns like HTTP middleware, security, testing, and observability integration. Each section includes working examples you can run immediately.&lt;/p&gt;</description></item><item><title>gRPC in Go Complete Guide from Basics to Production Ready Services</title><link>https://www.buanacoding.com/2025/08/grpc-in-go-complete-guide-basics-production.html</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0000</pubDate><guid>https://www.buanacoding.com/2025/08/grpc-in-go-complete-guide-basics-production.html</guid><description>&lt;p&gt;Building modern distributed systems is tricky business - you need services that can talk to each other quickly and reliably. That&amp;rsquo;s where gRPC comes in and absolutely crushes it. I&amp;rsquo;ve been building REST APIs for years, but when I first tried gRPC, it was like switching from a bicycle to a sports car. The speed difference is insane, plus you get type safety and can use it with practically any programming language.&lt;/p&gt;</description></item><item><title>Connecting to PostgreSQL in Go using sqlx</title><link>https://www.buanacoding.com/2025/05/connecting-postgresql-in-go-using-sqlx.html</link><pubDate>Sun, 25 May 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/05/connecting-postgresql-in-go-using-sqlx.html</guid><description>&lt;p&gt;In modern web applications, storing and retrieving data from a database is a fundamental requirement. Go provides a low-level database/sql package, but using it directly can be verbose and repetitive. Thankfully, sqlx extends database/sql by adding useful features like struct scanning and named queries, making database operations in Go much easier.&lt;/p&gt;
&lt;p&gt;In this article, we’ll walk through how to connect a Go application to a PostgreSQL database using sqlx, and how to perform basic CRUD operations.&lt;/p&gt;</description></item><item><title>Structuring Go Projects Clean Project Structure and Best Practices</title><link>https://www.buanacoding.com/2025/05/structuring-go-projects-clean-architecture.html</link><pubDate>Sun, 18 May 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/05/structuring-go-projects-clean-architecture.html</guid><description>&lt;p&gt;When you start building larger applications in Go, having a clean and maintainable project structure is essential. Unlike some other languages or frameworks that enforce certain patterns, Go gives you a lot of freedom in how you organize your code. While this is powerful, it can also lead to messy projects if not handled carefully.&lt;/p&gt;
&lt;p&gt;In this guide, we&amp;rsquo;ll explore how to structure Go projects following clean architecture principles and best practices that many professional Go developers use.&lt;/p&gt;</description></item><item><title>How to Build a REST API in Go using net/http</title><link>https://www.buanacoding.com/2025/05/how-to-build-rest-api-in-go-using-net-http.html</link><pubDate>Sun, 11 May 2025 08:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/05/how-to-build-rest-api-in-go-using-net-http.html</guid><description>&lt;p&gt;Building a REST API in Go is one of the most practical ways to learn how Go handles HTTP servers, &lt;a href="https://www.buanacoding.com/2025/04/working-with-json-in-go-encode-decode.html"&gt;
 JSON
&lt;/a&gt;
, and struct-based logic. In this tutorial, you’ll learn how to create a simple RESTful API using the standard net/http package—without using any third-party frameworks. This is a great starting point before moving to more complex architectures.&lt;/p&gt;
&lt;p&gt;In this guide, we’ll create a simple API for managing books. Each book will have an ID, title, and author.&lt;/p&gt;</description></item><item><title>Encode, Decode, and Tag Structs</title><link>https://www.buanacoding.com/2025/04/working-with-json-in-go-encode-decode.html</link><pubDate>Wed, 30 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/working-with-json-in-go-encode-decode.html</guid><description>&lt;p&gt;JSON (JavaScript Object Notation) is a widely used data format in APIs and web applications. Go provides strong support for JSON through the standard &lt;code&gt;encoding/json&lt;/code&gt; package. In this article, you’ll learn how to parse JSON into structs, generate JSON from Go data, use struct tags, and work with nested or dynamic structures.&lt;/p&gt;
&lt;p&gt;In this article, you’ll learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to encode Go structs to JSON&lt;/li&gt;
&lt;li&gt;How to decode JSON into Go structs&lt;/li&gt;
&lt;li&gt;Using JSON tags to customize field names&lt;/li&gt;
&lt;li&gt;Working with maps and dynamic JSON&lt;/li&gt;
&lt;li&gt;Handling nested JSON structures&lt;/li&gt;
&lt;li&gt;Best practices and error handling&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="encoding-structs-to-json"&gt;Encoding Structs to JSON&lt;/h2&gt;
&lt;p&gt;Use &lt;code&gt;json.Marshal&lt;/code&gt; to convert Go structs into JSON strings:&lt;/p&gt;</description></item><item><title>Read, Write, and Manage Files</title><link>https://www.buanacoding.com/2025/04/file-handling-in-go-read-write-and.html</link><pubDate>Tue, 29 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/file-handling-in-go-read-write-and.html</guid><description>&lt;p&gt;In Go, file handling is straightforward and powerful. You can create, read, write, and manage files using standard packages like &lt;code&gt;os&lt;/code&gt;, &lt;code&gt;io&lt;/code&gt;, and &lt;code&gt;ioutil&lt;/code&gt; (deprecated but still common). Understanding how to work with files is essential when building CLI tools, web servers, or any application that deals with local data.&lt;/p&gt;
&lt;p&gt;In this article, you’ll learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to create and write to a file&lt;/li&gt;
&lt;li&gt;How to read a file&lt;/li&gt;
&lt;li&gt;Appending data to files&lt;/li&gt;
&lt;li&gt;Working with directories&lt;/li&gt;
&lt;li&gt;Checking if a file exists&lt;/li&gt;
&lt;li&gt;Best practices and error handling&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="creating-and-writing-to-a-file"&gt;Creating and Writing to a File&lt;/h2&gt;
&lt;p&gt;To create and write content to a file:&lt;/p&gt;</description></item><item><title>Using sync.Mutex and sync.Once</title><link>https://www.buanacoding.com/2025/04/synchronizing-goroutines-in-go-using.html</link><pubDate>Mon, 28 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/synchronizing-goroutines-in-go-using.html</guid><description>&lt;p&gt;When you write concurrent programs in Go, multiple goroutines may try to access and modify the same data at the same time. Without proper synchronization, this leads to race conditions, bugs, or crashes. Go provides tools like &lt;code&gt;sync.Mutex&lt;/code&gt;, &lt;code&gt;sync.RWMutex&lt;/code&gt;, and &lt;code&gt;sync.Once&lt;/code&gt; to safely share data across goroutines.&lt;/p&gt;
&lt;p&gt;In this article, you’ll learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What race conditions are and how to avoid them&lt;/li&gt;
&lt;li&gt;How to use &lt;code&gt;sync.Mutex&lt;/code&gt; to protect data&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;sync.RWMutex&lt;/code&gt; for read-write access&lt;/li&gt;
&lt;li&gt;How &lt;code&gt;sync.Once&lt;/code&gt; ensures code runs only once&lt;/li&gt;
&lt;li&gt;Real-world examples and best practices&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-is-a-race-condition"&gt;What Is a Race Condition?&lt;/h2&gt;
&lt;p&gt;A race condition happens when two or more goroutines access the same variable at the same time, and at least one of them is modifying it. This can cause unexpected behavior or corrupted data.&lt;/p&gt;</description></item><item><title>Cancellation, Timeout, and Deadlines Explained</title><link>https://www.buanacoding.com/2025/04/using-context-in-go-cancellation.html</link><pubDate>Sun, 27 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/using-context-in-go-cancellation.html</guid><description>&lt;p&gt;As your Go applications become more concurrent and complex, you&amp;rsquo;ll need a way to manage the lifecycle of your goroutines—especially when you want to cancel them, set timeouts, or propagate deadlines. This is where the &lt;code&gt;context&lt;/code&gt; package comes in. It&amp;rsquo;s the idiomatic way in Go to control concurrent processes gracefully and reliably.&lt;/p&gt;
&lt;p&gt;In this article, you’ll learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What &lt;code&gt;context&lt;/code&gt; is and why it’s important&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;context.Background()&lt;/code&gt; and &lt;code&gt;context.TODO()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;How to cancel a goroutine with &lt;code&gt;context.WithCancel()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;How to set a timeout or deadline&lt;/li&gt;
&lt;li&gt;How to check if a context is done&lt;/li&gt;
&lt;li&gt;Real-world examples and best practices&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-is-context"&gt;What Is Context?&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;context&lt;/code&gt; package provides a way to carry deadlines, cancellation signals, and other request-scoped values across function boundaries and between goroutines.&lt;/p&gt;</description></item><item><title>Goroutines and Channels Explained</title><link>https://www.buanacoding.com/2025/04/concurrency-in-go-goroutines-and.html</link><pubDate>Sat, 26 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/concurrency-in-go-goroutines-and.html</guid><description>&lt;p&gt;One of the most powerful features of Go is its built-in support for concurrency. Go makes it easy to write programs that perform multiple tasks at the same time, thanks to goroutines and channels. Unlike traditional multithreading, Go provides a lightweight and clean way to build concurrent systems with minimal overhead and boilerplate.&lt;/p&gt;
&lt;p&gt;In this article, you’ll learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The difference between concurrency and parallelism&lt;/li&gt;
&lt;li&gt;What goroutines are and how to use them&lt;/li&gt;
&lt;li&gt;How channels allow communication between goroutines&lt;/li&gt;
&lt;li&gt;Buffered vs unbuffered channels&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;select&lt;/code&gt; statement&lt;/li&gt;
&lt;li&gt;Common concurrency problems and how to avoid them&lt;/li&gt;
&lt;li&gt;Real-world examples and best practices&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="concurrency-vs-parallelism"&gt;Concurrency vs Parallelism&lt;/h2&gt;
&lt;p&gt;Concurrency means doing multiple things at once (interleaved), while parallelism means running them simultaneously on different processors. Go’s concurrency model allows you to write code that is concurrent, and Go’s runtime handles whether it is executed in parallel depending on available CPU cores.&lt;/p&gt;</description></item><item><title>Writing Reusable and Type-Safe Code</title><link>https://www.buanacoding.com/2025/04/generics-in-go-writing-reusable-and-type-safe-code.html</link><pubDate>Fri, 25 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/generics-in-go-writing-reusable-and-type-safe-code.html</guid><description>&lt;p&gt;Generics were introduced in Go 1.18, marking a significant evolution of the language. They allow you to write flexible, reusable code without sacrificing type safety. With generics, you can define functions, types, and data structures that work with different types, all while maintaining strong compile-time checks.&lt;/p&gt;
&lt;p&gt;In this article, you’ll learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What generics are and why they matter&lt;/li&gt;
&lt;li&gt;How to define generic functions and types&lt;/li&gt;
&lt;li&gt;Type parameters and constraints&lt;/li&gt;
&lt;li&gt;Real-world examples of generics&lt;/li&gt;
&lt;li&gt;Best practices when using generics in Go&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-are-generics"&gt;What Are Generics?&lt;/h2&gt;
&lt;p&gt;Generics let you write code that works with different data types while keeping the benefits of static typing. Before generics, developers often used &lt;code&gt;interface{}&lt;/code&gt; and type assertions to achieve flexibility, but that meant losing compile-time type safety.&lt;/p&gt;</description></item><item><title>Measuring Performance with testing.B</title><link>https://www.buanacoding.com/2025/04/benchmarking-in-go-measuring.html</link><pubDate>Thu, 24 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/benchmarking-in-go-measuring.html</guid><description>&lt;p&gt;Benchmarking is the process of measuring the performance of code. In Go, benchmarking is built into the standard &lt;code&gt;testing&lt;/code&gt; package, making it easy to test how fast your functions run. Whether you&amp;rsquo;re comparing two algorithms, optimizing critical sections of code, or experimenting with concurrency, benchmarking helps you make informed decisions.&lt;/p&gt;
&lt;p&gt;This article will walk you through:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What is benchmarking and why it matters&lt;/li&gt;
&lt;li&gt;How to write benchmark functions in Go&lt;/li&gt;
&lt;li&gt;Interpreting benchmark results&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;b.ResetTimer()&lt;/code&gt;, &lt;code&gt;b.StopTimer()&lt;/code&gt;, and &lt;code&gt;b.StartTimer()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Common use cases for benchmarking&lt;/li&gt;
&lt;li&gt;Best practices for writing meaningful benchmarks&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="why-benchmarking-is-important"&gt;Why Benchmarking is Important&lt;/h2&gt;
&lt;p&gt;Benchmarking allows you to evaluate performance based on data, not assumptions. You can compare the execution time of different code versions, measure improvements, and catch performance regressions early. This is crucial for optimizing critical parts of applications such as sorting, searching, or processing large datasets.&lt;/p&gt;</description></item><item><title>Writing Unit Tests with the Testing Package</title><link>https://www.buanacoding.com/2025/04/testing-in-go-writing-unit-tests-with.html</link><pubDate>Wed, 23 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/testing-in-go-writing-unit-tests-with.html</guid><description>&lt;p&gt;Testing is one of the most important parts of software development, yet often overlooked. In Go, testing is not an afterthought — it&amp;rsquo;s built into the language itself through the powerful and easy-to-use &lt;code&gt;testing&lt;/code&gt; package. Whether you&amp;rsquo;re building a web app, API, or CLI tool, writing tests will help you catch bugs early, document your code, and refactor safely.&lt;/p&gt;
&lt;p&gt;This article will help you understand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Why testing matters in software development&lt;/li&gt;
&lt;li&gt;The basics of writing tests in Go&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;t.Error&lt;/code&gt;, &lt;code&gt;t.Fail&lt;/code&gt;, and &lt;code&gt;t.Fatal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Table-driven tests&lt;/li&gt;
&lt;li&gt;Running and understanding test results&lt;/li&gt;
&lt;li&gt;Measuring code coverage&lt;/li&gt;
&lt;li&gt;Best practices for writing useful tests&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="why-testing-is-important"&gt;Why Testing is Important&lt;/h2&gt;
&lt;p&gt;Testing helps you ensure that your code works as expected — not just today, but as it evolves. Without tests, it&amp;rsquo;s risky to make changes because you can&amp;rsquo;t be confident you haven&amp;rsquo;t broken something.&lt;/p&gt;</description></item><item><title>Managing Errors the Right Way</title><link>https://www.buanacoding.com/2025/04/error-handling-in-go-managing-errors.html</link><pubDate>Tue, 22 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/error-handling-in-go-managing-errors.html</guid><description>&lt;p&gt;Error handling is a core part of Go programming. Unlike many languages that use exceptions, Go takes a more straightforward and explicit approach. In Go, functions often return an error as the last return value, and it&amp;rsquo;s the developer’s job to check and handle it. This method may seem verbose at first, but it leads to more robust and predictable code.&lt;/p&gt;
&lt;p&gt;In this article, you&amp;rsquo;ll learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What an error is in Go&lt;/li&gt;
&lt;li&gt;How to handle errors using &lt;code&gt;if err != nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Creating custom errors&lt;/li&gt;
&lt;li&gt;Error wrapping with Go 1.13+&lt;/li&gt;
&lt;li&gt;Custom error types&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;panic&lt;/code&gt; and &lt;code&gt;recover&lt;/code&gt; (when and why)&lt;/li&gt;
&lt;li&gt;Best practices for error handling&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-is-an-error-in-go"&gt;What is an Error in Go?&lt;/h2&gt;
&lt;p&gt;In Go, the &lt;code&gt;error&lt;/code&gt; type is a built-in interface:&lt;/p&gt;</description></item><item><title>Building Flexible and Reusable Code</title><link>https://www.buanacoding.com/2025/04/interfaces-in-go-building-flexible-and.html</link><pubDate>Mon, 21 Apr 2025 10:30:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/interfaces-in-go-building-flexible-and.html</guid><description>&lt;p&gt;Interfaces are one of the most important features in Go. They allow you to write flexible, reusable, and loosely coupled code. In Go, an interface defines a set of method signatures, and any type that implements those methods satisfies the interface — without needing to explicitly declare that it does so. This is a powerful concept that supports polymorphism and clean architecture in Go applications.&lt;/p&gt;
&lt;p&gt;In this article, you&amp;rsquo;ll learn:&lt;/p&gt;</description></item><item><title>Reference Types and Receivers Explained</title><link>https://www.buanacoding.com/2025/04/understanding-pointers-in-go-reference.html</link><pubDate>Sun, 20 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/understanding-pointers-in-go-reference.html</guid><description>&lt;p&gt;In Go, understanding pointers is essential if you want to work effectively with functions, methods, and memory-efficient code. Unlike some other languages, Go’s approach to pointers is clean and straightforward—there’s no pointer arithmetic, and most things can be done without overly complex syntax.&lt;/p&gt;
&lt;p&gt;This article will help you understand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What pointers are in Go and how they work&lt;/li&gt;
&lt;li&gt;Using pointers in functions&lt;/li&gt;
&lt;li&gt;Method receivers: value vs pointer&lt;/li&gt;
&lt;li&gt;Choosing between value or pointer receiver&lt;/li&gt;
&lt;li&gt;Common mistakes with pointers&lt;/li&gt;
&lt;li&gt;Best practices for using pointers effectively&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-is-a-pointer"&gt;What is a Pointer?&lt;/h2&gt;
&lt;p&gt;A pointer is a variable that stores the memory address of another variable. You use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to get the address and &lt;code&gt;*&lt;/code&gt; to access the value at that address.&lt;/p&gt;</description></item><item><title>Defining and Using Custom Types</title><link>https://www.buanacoding.com/2025/04/structs-and-methods-in-go-defining-and.html</link><pubDate>Sat, 19 Apr 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/structs-and-methods-in-go-defining-and.html</guid><description>&lt;p&gt;In Go, a struct is a powerful way to group related data together. It allows you to define your own custom types by combining variables (also called fields). Structs are often used to model real-world entities like users, products, or messages. When combined with methods, structs become the foundation for writing clean and reusable code in Go.&lt;/p&gt;
&lt;p&gt;In this article, you&amp;rsquo;ll learn:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to define and use structs in Go&lt;/li&gt;
&lt;li&gt;How to attach methods to a struct&lt;/li&gt;
&lt;li&gt;The difference between value and pointer receivers&lt;/li&gt;
&lt;li&gt;Best practices for using structs and methods effectively&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="defining-a-struct"&gt;Defining a Struct&lt;/h2&gt;
&lt;p&gt;To define a struct, you use the &lt;code&gt;type&lt;/code&gt; keyword followed by the name of the struct and the &lt;code&gt;struct&lt;/code&gt; keyword:&lt;/p&gt;</description></item><item><title>A Beginner's Guide</title><link>https://www.buanacoding.com/2025/04/understanding-functions-in-go-beginners.html</link><pubDate>Fri, 18 Apr 2025 11:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/understanding-functions-in-go-beginners.html</guid><description>&lt;p&gt;Functions are an essential part of programming in any language, and Go is no exception. A function lets you organize code into reusable blocks, which helps reduce duplication and improve readability. In this article, you’ll learn how functions work in Go, how to define them, use them, and apply best practices.&lt;/p&gt;
&lt;p&gt;This guide covers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to define and call a function in Go&lt;/li&gt;
&lt;li&gt;Function parameters and return values&lt;/li&gt;
&lt;li&gt;Multiple return values&lt;/li&gt;
&lt;li&gt;Named return values&lt;/li&gt;
&lt;li&gt;Variadic functions&lt;/li&gt;
&lt;li&gt;Functions as values and arguments&lt;/li&gt;
&lt;li&gt;Best practices for clean function design&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="defining-and-calling-a-function"&gt;Defining and Calling a Function&lt;/h2&gt;
&lt;p&gt;To define a function in Go, use the &lt;code&gt;func&lt;/code&gt; keyword, followed by the function name, parameters, and return type (if any). Here&amp;rsquo;s a simple example:&lt;/p&gt;</description></item><item><title>Arrays, Slices, and Maps Explained</title><link>https://www.buanacoding.com/2025/04/working-with-collections-in-go-arrays.html</link><pubDate>Thu, 17 Apr 2025 22:46:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/working-with-collections-in-go-arrays.html</guid><description>&lt;p&gt;When building applications in Go, it&amp;rsquo;s common to work with groups of data. For example, you might want to store a list of user names, or map names to scores. In Go, you can use collections like arrays, slices, and maps to do that.&lt;/p&gt;
&lt;p&gt;In this article, we’ll explore:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What arrays are and how they work&lt;/li&gt;
&lt;li&gt;How slices offer more flexibility&lt;/li&gt;
&lt;li&gt;What maps are and how to use them&lt;/li&gt;
&lt;li&gt;Common operations with collections&lt;/li&gt;
&lt;li&gt;Practical examples to understand the difference between them&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s dive in and learn how Go helps us manage grouped data efficiently.&lt;/p&gt;</description></item><item><title>for, range, break, and continue Explained</title><link>https://www.buanacoding.com/2025/04/understanding-loops-in-go-for-range.html</link><pubDate>Wed, 16 Apr 2025 22:06:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/understanding-loops-in-go-for-range.html</guid><description>&lt;p&gt;Loops are a key part of programming. They let us run the same piece of code multiple times without repeating ourselves. In Go, loops are simple but powerful — and they&amp;rsquo;re built using just one keyword: for.&lt;/p&gt;
&lt;p&gt;In this article, we’ll explore:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The basic for loop in Go&lt;/li&gt;
&lt;li&gt;Using for as a while loop&lt;/li&gt;
&lt;li&gt;Looping with range&lt;/li&gt;
&lt;li&gt;Breaking or skipping parts of loops with break and continue&lt;/li&gt;
&lt;li&gt;Real-world examples to help you understand how loops work&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-is-a-loop"&gt;What is a Loop?&lt;/h2&gt;
&lt;p&gt;A loop is a way to repeat a block of code as long as a condition remains true. Instead of writing similar code many times, we can put it in a loop and let the program handle the repetition. This makes our code shorter, cleaner, and easier to manage. Go uses the keyword for for all loop types, which makes it both simple and flexible.&lt;/p&gt;</description></item><item><title>Understanding Conditional Statements in Go (if, switch, etc.)</title><link>https://www.buanacoding.com/2025/04/understanding-conditional-statements-in.html</link><pubDate>Tue, 15 Apr 2025 19:09:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/04/understanding-conditional-statements-in.html</guid><description>&lt;p&gt;Conditional statements are one of the essential building blocks in any programming language, including Go. They allow us to make decisions in our code — telling the program to do something only if a certain condition is true.&lt;/p&gt;
&lt;p&gt;In this article, we will explore:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The if, else, and else if statements&lt;/li&gt;
&lt;li&gt;The switch statement&lt;/li&gt;
&lt;li&gt;Best practices for using conditionals in Go&lt;/li&gt;
&lt;li&gt;Real examples to help you practice&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="what-is-a-conditional-statement"&gt;What is a Conditional Statement?&lt;/h2&gt;
&lt;p&gt;A conditional statement evaluates whether a condition is true or false. Based on that, your Go program can choose which block of code to execute.&lt;/p&gt;</description></item><item><title>Basics and Practical Examples</title><link>https://www.buanacoding.com/2024/07/understanding-string-data-type-in-go.html</link><pubDate>Mon, 22 Jul 2024 07:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2024/07/understanding-string-data-type-in-go.html</guid><description>&lt;p&gt;In our series on understanding data types in the Go programming language, after discussing numeric and boolean types, we will now explore strings. Strings are one of the most frequently used data types in programming due to their ubiquitous use in handling text. In Go, strings have several unique characteristics that we will explore in this article.&lt;/p&gt;
&lt;h2 id="introduction-to-strings"&gt;Introduction to Strings&lt;/h2&gt;
&lt;p&gt;In Go, a string is a sequence of immutable bytes. This means that once a string value is set, it cannot be changed without creating a new string.&lt;/p&gt;</description></item><item><title>Basics and Practical Examples</title><link>https://www.buanacoding.com/2024/07/understanding-numeric-data-type-in-go.html</link><pubDate>Sat, 20 Jul 2024 19:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2024/07/understanding-numeric-data-type-in-go.html</guid><description>&lt;p&gt;Go, also known as Golang, is a statically typed language developed by Google. It&amp;rsquo;s known for its simplicity and efficiency, especially when it comes to systems and concurrent programming. In this article, we&amp;rsquo;ll explore the numeric types in Go and provide practical examples to illustrate their usage.&lt;/p&gt;
&lt;h2 id="basic-numeric-types"&gt;Basic Numeric Types&lt;/h2&gt;
&lt;p&gt;Go offers several basic numeric types categorized into integers, floating point numbers, and complex numbers. Here’s a quick overview:&lt;/p&gt;
&lt;h3 id="integer"&gt;Integer&lt;/h3&gt;
&lt;p&gt;Integer types are divided into two categories, signed and unsigned. The signed integers &lt;strong&gt;int8, int16, int32, int64&lt;/strong&gt; can hold both negative and positive values, whereas unsigned integers &lt;strong&gt;int8, int16, int32, int64&lt;/strong&gt; can only hold positive values and zero.&lt;/p&gt;</description></item><item><title>Basics and Practical Examples</title><link>https://www.buanacoding.com/2024/07/understanding-booleans-in-go-basics.html</link><pubDate>Thu, 18 Jul 2024 19:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2024/07/understanding-booleans-in-go-basics.html</guid><description>&lt;p&gt;In the Go programming language, as in many other programming languages, the boolean data type is fundamental. It represents truth values, either true or false. Booleans are crucial in software development for decision-making, allowing developers to control the flow of execution through conditional statements like if, else, and looping constructs such as for.&lt;/p&gt;
&lt;p&gt;Declaration and Initialization&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;To declare a boolean in Go, you use the keyword &lt;strong&gt;bool&lt;/strong&gt;. Here&amp;rsquo;s how you can declare and initialize a boolean variable:&lt;/p&gt;</description></item><item><title>Easiest Way to Install Golang on Linux Snap or Manual Source?</title><link>https://www.buanacoding.com/2024/04/easiest-way-install-golang-on-linux.html</link><pubDate>Mon, 08 Apr 2024 06:23:00 +0700</pubDate><guid>https://www.buanacoding.com/2024/04/easiest-way-install-golang-on-linux.html</guid><description>&lt;p&gt;Learning Golang recently opened up new perspectives for me in software development. One of the best ways to solidify your understanding is by teaching others. That’s why in this article, I’m sharing my experience installing Go on Linux—using both Snap and manual source installation.&lt;/p&gt;
&lt;p&gt;Writing this guide not only helps others get started, but also helps reinforce the steps in my own memory.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="installing-golang-using-snap"&gt;Installing Golang Using Snap&lt;/h2&gt;
&lt;p&gt;Snap is a universal package manager developed by Canonical (Ubuntu’s creator). It simplifies app installation by bundling dependencies, ensuring compatibility across most Linux distributions.&lt;/p&gt;</description></item></channel></rss>