<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Backend on Buana Coding</title><link>https://www.buanacoding.com/tags/backend/</link><description>Recent content in Backend on Buana Coding</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 06 Oct 2025 18:00:00 +0700</lastBuildDate><atom:link href="https://www.buanacoding.com/tags/backend/index.xml" rel="self" type="application/rss+xml"/><item><title>How to Send Emails in Go - SMTP, SendGrid, and Mailgun Integration</title><link>https://www.buanacoding.com/2025/10/how-to-send-emails-in-go-smtp-sendgrid-mailgun.html</link><pubDate>Mon, 06 Oct 2025 18:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/10/how-to-send-emails-in-go-smtp-sendgrid-mailgun.html</guid><description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Your application needs to send emails. Welcome messages after signup, password reset links, order confirmations, notification alerts. Email is still the most reliable way to reach users, but sending emails programmatically is harder than it looks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What is email sending in Go?&lt;/strong&gt; Email sending in Go refers to programmatically delivering emails from your application using either SMTP protocol directly or third-party email service APIs like SendGrid and Mailgun. Instead of manually composing and sending emails, your Go code automatically sends transactional emails triggered by user actions.&lt;/p&gt;</description></item><item><title>How to Implement Background Jobs in Go with Asynq and Redis</title><link>https://www.buanacoding.com/2025/10/how-to-implement-background-jobs-in-go-with-asynq-and-redis.html</link><pubDate>Mon, 06 Oct 2025 16:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/10/how-to-implement-background-jobs-in-go-with-asynq-and-redis.html</guid><description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Your API is slow. Not because the code is inefficient, but because you&amp;rsquo;re doing too much in the HTTP request cycle. Sending emails, processing images, generating reports - all blocking the response while the user waits. That&amp;rsquo;s not how you scale.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What are background jobs?&lt;/strong&gt; Background jobs are tasks that run asynchronously outside the main request-response cycle. Instead of making users wait while your server processes heavy workloads, you push these tasks into a queue and handle them separately in worker processes. This keeps your API fast and responsive.&lt;/p&gt;</description></item><item><title>How to Profile and Optimize Go Applications with pprof</title><link>https://www.buanacoding.com/2025/10/how-to-profile-and-optimize-go-applications-with-pprof.html</link><pubDate>Mon, 06 Oct 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/10/how-to-profile-and-optimize-go-applications-with-pprof.html</guid><description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Your Go application is slow. Requests take too long, memory usage keeps climbing, or CPU maxes out under load. You need answers, not guesses. That&amp;rsquo;s where pprof comes in.&lt;/p&gt;
&lt;p&gt;pprof is Go&amp;rsquo;s built-in profiler that shows you exactly what&amp;rsquo;s happening inside your running application. It tells you which functions eat CPU cycles, which code paths allocate tons of memory, where goroutines get stuck, and what&amp;rsquo;s blocking your program. With this data, you stop guessing and start fixing real bottlenecks.&lt;/p&gt;</description></item><item><title>How to Perform Database Migrations in Go using golang-migrate</title><link>https://www.buanacoding.com/2025/10/how-to-perform-database-migrations-in-go-using-golang-migrate.html</link><pubDate>Sun, 05 Oct 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/10/how-to-perform-database-migrations-in-go-using-golang-migrate.html</guid><description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Managing database schema changes is one of those tasks that seems simple until you&amp;rsquo;re dealing with multiple environments, team members making conflicting changes, or trying to rollback a production deployment at 2 AM. If you&amp;rsquo;ve ever manually run SQL scripts on production hoping you didn&amp;rsquo;t miss anything, you know exactly what I&amp;rsquo;m talking about.&lt;/p&gt;
&lt;p&gt;golang-migrate solves this problem by giving you version control for your database schema. Just like git tracks code changes, migrations track schema changes. You can move forward, rollback, and know exactly what state your database is in at any time.&lt;/p&gt;</description></item><item><title>How to Upload Files to AWS S3 in Go Complete Guide with SDK v2</title><link>https://www.buanacoding.com/2025/10/how-to-upload-files-to-aws-s3-in-go-with-sdk-v2.html</link><pubDate>Fri, 03 Oct 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/10/how-to-upload-files-to-aws-s3-in-go-with-sdk-v2.html</guid><description>&lt;p&gt;If you&amp;rsquo;ve built any real application, you know file storage becomes a problem fast. User avatars, document uploads, video files - they pile up quickly, and you need somewhere reliable to put them. That&amp;rsquo;s where AWS S3 comes in. It&amp;rsquo;s like having unlimited storage that you only pay for what you use, and it integrates beautifully with Go.&lt;/p&gt;
&lt;p&gt;AWS recently rewrote their entire Go SDK with v2, and honestly, it&amp;rsquo;s a massive improvement. Cleaner APIs, better error handling, proper context support - everything you&amp;rsquo;d want in a modern Go library. If you&amp;rsquo;re starting fresh or thinking about upgrading from v1, this guide has you covered.&lt;/p&gt;</description></item></channel></rss>