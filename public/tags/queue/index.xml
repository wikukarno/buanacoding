<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Queue on Buana Coding</title>
    <link>http://localhost:1313/tags/queue/</link>
    <description>Recent content in Queue on Buana Coding</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 06 Oct 2025 16:00:00 +0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to Implement Background Jobs in Go with Asynq and Redis</title>
      <link>http://localhost:1313/2025/10/how-to-implement-background-jobs-in-go-with-asynq-and-redis.html</link>
      <pubDate>Mon, 06 Oct 2025 16:00:00 +0700</pubDate>
      <guid>http://localhost:1313/2025/10/how-to-implement-background-jobs-in-go-with-asynq-and-redis.html</guid>
      <description>&lt;!-- raw HTML omitted --&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;p&gt;Your API is slow. Not because the code is inefficient, but because you&amp;rsquo;re doing too much in the HTTP request cycle. Sending emails, processing images, generating reports - all blocking the response while the user waits. That&amp;rsquo;s not how you scale.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;What are background jobs?&lt;/strong&gt; Background jobs are tasks that run asynchronously outside the main request-response cycle. Instead of making users wait while your server processes heavy workloads, you push these tasks into a queue and handle them separately in worker processes. This keeps your API fast and responsive.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Easy Background Processing Tutorial</title>
      <link>http://localhost:1313/2025/09/laravel-queue-jobs-background-processing-tutorial.html</link>
      <pubDate>Wed, 24 Sep 2025 10:00:00 +0700</pubDate>
      <guid>http://localhost:1313/2025/09/laravel-queue-jobs-background-processing-tutorial.html</guid>
      <description>&lt;p&gt;Ever had a user complain that your app takes forever to send an email or process an image upload? Or maybe you&amp;rsquo;ve watched your response times crawl to a halt because you&amp;rsquo;re trying to do too much work during a single request? Laravel queues are the solution you&amp;rsquo;ve been looking for, and they&amp;rsquo;re easier to set up than you might think.&lt;/p&gt;&#xA;&lt;p&gt;Think of Laravel queues as your app&amp;rsquo;s personal assistant. Instead of making users wait while you send emails, resize images, or generate reports, you hand these tasks off to the background and let users continue with their day. The work still gets done, but it doesn&amp;rsquo;t block the user experience.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
