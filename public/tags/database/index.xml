<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database on Buana Coding</title><link>https://www.buanacoding.com/tags/database/</link><description>Recent content in Database on Buana Coding</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 22 Sep 2025 10:00:00 +0700</lastBuildDate><atom:link href="https://www.buanacoding.com/tags/database/index.xml" rel="self" type="application/rss+xml"/><item><title>Laravel N+1 Query Problem Solution Essential Database Optimization Guide</title><link>https://www.buanacoding.com/2025/09/laravel-n-plus-one-query-problem-solution.html</link><pubDate>Mon, 22 Sep 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/laravel-n-plus-one-query-problem-solution.html</guid><description>&lt;p&gt;If you&amp;rsquo;ve ever wondered why your Laravel app suddenly becomes sluggish when displaying lists of data, you might be dealing with the dreaded N+1 query problem. It&amp;rsquo;s one of those sneaky performance killers that can turn a fast application into a slow, resource-hungry monster. Don&amp;rsquo;t worry though - once you understand what&amp;rsquo;s happening and how to fix it, you&amp;rsquo;ll never fall into this trap again.&lt;/p&gt;
&lt;h2 id="what-is-the-n1-query-problem"&gt;What is the N+1 Query Problem?&lt;/h2&gt;
&lt;p&gt;Here&amp;rsquo;s what happens: your app makes one query to get a list of records, then fires off a separate query for each record to grab related data. Picture this - you want to show 100 blog posts with their authors&amp;rsquo; names. Instead of being smart about it, your app runs one query to get the posts, then 100 more queries to fetch each author. That&amp;rsquo;s 101 database hits when you could&amp;rsquo;ve done it with just 2!&lt;/p&gt;</description></item><item><title>Avoiding Fatal Mistakes</title><link>https://www.buanacoding.com/2025/09/laravel-database-migration-best-practices.html</link><pubDate>Mon, 15 Sep 2025 10:00:00 +0700</pubDate><guid>https://www.buanacoding.com/2025/09/laravel-database-migration-best-practices.html</guid><description>&lt;p&gt;Migrations let you evolve your schema alongside the code. Done well, they are repeatable and safe. Done poorly, they lock tables, drop data, and take your site down. This guide focuses on practical patterns that reduce risk in production and make rollouts predictable.&lt;/p&gt;
&lt;h2 id="ground-rules"&gt;Ground rules&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Treat migrations as immutable once deployed. If a mistake gets to production, add a new migration to correct it instead of editing history.&lt;/li&gt;
&lt;li&gt;Keep schema and data changes separate. Data backfills belong in their own migration or a job/command so you can control runtime and retries.&lt;/li&gt;
&lt;li&gt;Don’t rely on application models inside migrations. Models can drift as your app evolves. Prefer &lt;code&gt;DB::table()&lt;/code&gt; or raw SQL that doesn’t depend on future code.&lt;/li&gt;
&lt;li&gt;Test locally and in staging with the same DB engine and major version you run in production.&lt;/li&gt;
&lt;li&gt;Always run with &lt;code&gt;php artisan migrate --force&lt;/code&gt; in CI/production. Check status with &lt;code&gt;php artisan migrate:status&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="naming-and-versioning"&gt;Naming and versioning&lt;/h2&gt;
&lt;p&gt;Use descriptive names that read like a change log: &lt;code&gt;2025_09_15_100001_add_status_to_orders_table.php&lt;/code&gt;. One concern per migration. If a change requires several steps (add column → backfill → enforce NOT NULL), use separate migrations in the right order.&lt;/p&gt;</description></item></channel></rss>